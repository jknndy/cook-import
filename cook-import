#!/usr/bin/env python3

import argparse
import re
import sys
import requests

from recipe_scrapers import scrape_html, WebsiteNotImplementedError, NoSchemaFoundInWildMode
from ingredient_parser import parse_ingredient

from utils import eprint, sub_lists, print_recipe, highlight_replacement_in_text, HEADERS
# List of single stop words used to remove from ingredient list. Prevents outputs like @onion @powder{1%tbsp}{1%tbsp}
single_stop_words = {"and", "or", "for", "the", "of", "powder", "syrup", "pinch", "cheese", "ground", "powdered", "seeds"}

# List of small amount types to convert quantity from 0 to 1.
small_amount_words = {"dash", "pinch", "sprinkle", "smidgen", "drop", "bunch"}

parser = argparse.ArgumentParser(
    description="Automatically extract recipes from online websites."
)
parser.add_argument("-l", "--link", help="Input a URL link to a recipe")
parser.add_argument(
    "-f",
    "--file",
    help="If you want the output to be in a file, use this flag. Otherwise defaults to console screen.",
    action="store_true",
)
args = parser.parse_args()

# Check if no arguments are passed
if len(sys.argv) == 1:
    parser.print_help()
    sys.exit()

# Retrieve the HTML content
headers = HEADERS
html = requests.get(args.link, headers=headers).content

# Use the scrape_html function to parse the recipe
try:
    scraper = scrape_html(html, org_url=args.link)
except WebsiteNotImplementedError as e:
    try:
        scraper = scrape_html(html, org_url=args.link, wild_mode=True)
    except NoSchemaFoundInWildMode as exc:
        print(
            "The domain is currently not supported, %s. You can request adding this domain at https://github.com/hhursev/recipe-scrapers/issues" % e.domain)
        sys.exit(1)

# Extract recipe details
title = scraper.title()
image = scraper.image()
total_time = scraper.total_time()

eprint("Title:", title)
eprint("Image:", image)

instructions = scraper.instructions()
# Remove those pesky punctuation
ingredients_list = [
    parse_ingredient(re.sub(r"\.", "", ingredient))
    for ingredient in scraper.ingredients()
]

# Debug: Print out all ingredients
eprint("\nDebug: Ingredients List")
for idx, ingredient in enumerate(ingredients_list, 1):
    eprint(f"{idx}. {ingredient}")
eprint("")  # Add a blank line for readability

# Convert the timers
time_regex_match_str = r"(\d+|\d+\.\d+|\d+-\d+|\d+ to \d+) (min(?:utes)?|hours?|days?)"
instructions = re.sub(time_regex_match_str, r"~{\1%\2}", instructions)
def escape_regex_special_chars(text):
    return re.escape(text)
for combined_ingredient in ingredients_list:
    # Extract the actual ingredient name from the IngredientText object
    ingredient_name = combined_ingredient.name.text

    quantity = combined_ingredient.amount[0].quantity  # Ensure this is a single value
    unit = combined_ingredient.amount[0].unit  # Corrected to access unit from the first amount entry

    # Remove decimal places of whole numbers, such as 1.0 to 1
    if isinstance(quantity, (int, float)) and quantity % 1 == 0:
        quantity = int(quantity)

    # Truncate repeating decimals such as .333333
    if isinstance(quantity, float) and len(str(quantity)) > 5:
        quantity = f"{quantity:.2f}"

    # Unit is a small amount word and quantity is 0
    if ((unit in small_amount_words) and (quantity == 0)):
        quantity = 1

    # Create sublists for word matches
    # Idea is to greedily match as many words as possible
    ing_list = sub_lists(ingredient_name.split(" "))

    # Filter out empty sublist
    ing_list = list(filter(lambda x: len(x) > 0, ing_list))

    # Remove single stop words
    if len(ing_list) > 1:
        ing_list = list(
            filter(lambda x: x[0] not in single_stop_words, ing_list)
        )

    # Now generate regex string to match
    ing_list = sorted(ing_list, reverse=True, key=lambda x: len(x))
    ing_regex_match_str = "|".join([fr'\b{escape_regex_special_chars(" ".join(x))}\b' for x in ing_list])
    ing_regex_match_str = r"(?:[^@])(" + ing_regex_match_str + r")"
    
    # Debug: Print the regex pattern being compiled
    eprint(f"Debug: Regex pattern for '{ingredient_name}': {ing_regex_match_str}")

    # Ensure the regex pattern is valid
    try:
        ing_regex = re.compile(ing_regex_match_str, flags=re.I)
    except re.error as regex_error:
        eprint(f"Regex compilation error for ingredient '{ingredient_name}': {regex_error}")
        eprint(f"Problematic regex pattern: {ing_regex_match_str}")
        continue  # Skip this ingredient and move to the next one
    
    # regex match the text
    match_obj = ing_regex.search(instructions)

    eprint("")
    eprint(
        "✅" if match_obj else "❌",
        f"@{ingredient_name}{{{quantity}%{unit}}}" if unit else (f"@{ingredient_name}{{}}" if quantity == 0 else f"@{ingredient_name}{{{quantity}}}")
    )
    # If no match skip ingredient
    if match_obj is None:
        continue

    match_start = match_obj.start(1)
    match_end = match_obj.end(1)

    highlight_replacement_in_text(instructions, match_start, match_end)
    ing_replacement = f"@{match_obj[1]}{{{quantity}%{unit}}}" if unit != "" else (f"@{match_obj[1]}{{}}" if quantity == 0 else f"@{match_obj[1]}{{{quantity}}}")
    instructions = (
        instructions[0:match_start]
        + ing_replacement
        + instructions[match_end:]
    )

instructions = instructions.replace("\n", "\n\n")

print_recipe(title, args.link, total_time, image, instructions, to_file=args.file)
